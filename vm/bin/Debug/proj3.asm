SIZE .INT 7;//GLOBAL VARIABLES
CARRAY .INT 0;
.INT 0;
.INT 0;
.INT 0;
.INT 0;
.INT 0;
.INT 0;
DATA .INT 0;
OPDV .INT 0;
CNT .INT 0;
FLAG .INT 0;
TENTH .INT 0;
I .BYT I;
S .BYT S;
N .BYT N;
O .BYT O;
T .BYT T;
A .BYT A;
U .BYT U;
M .BYT M;
B .BYT B;
E .BYT E;
R .BYT R;
G .BYT G;
V .BYT V;
F .BYT F;
L .BYT L;
W .BYT W;
P .BYT P;
D .BYT D;
ZERO .INT 0;
ONE .INT 1;
FOUR .INT 4;
TEN .INT 10;
CZERO .INT 0;
CONE .INT 1;
CTWO .INT 2;
CTHREE .INT 3;
CFOUR .INT 4;
CFIVE .INT 5;
CSIX .INT 6;
CSEVEN .INT 7;
CEIGHT .INT 8;
CNINE .INT 9;
EXIT .BYT @;//"@"
PLUS .BYT +;// "+"
MINUS .BYT -;// "-"
CRETURN .INT 13;// "\R"
NEWLINE .INT 10;//"\n"
SPACE .INT 32;//" "

//SETUP
MOV FP SB;//INITIALIZE FP
MOV SP SB;//INITIALIZE SP

//SETUP TO CALL RESET()
//ALWAYS TEST FOR OVERFLOW
MOV R5 SP;
ADI R5 -24;//CHANGE TO THE NUMBER OF stored items X 4
CMP R5 SL;
BLT R5 OVERFLOW;
//ACTIVATION RECORD BEG
MOV R3 FP;//SAVE TO BE PFP
MOV FP SP;//SET FP
ADI SP -4;
STR R3 SP;STORE PFP
ADI SP -4;//ACTIVATION RECORD BEG
//****PASS PARAMETERS HERE****
LDR R2 ONE;
STR R2 SP;//W
ADI SP -4;
LDR R2 ZERO;
STR R2 SP;//X
ADI SP -4;
STR R2 SP;//Y
ADI SP -4;
STR R2 SP;//Z
ADI SP -4;
//****END OF PARAMETERS****
MOV R1 PC;//ACTIVATION RECORD END
ADI R1 44;//CALCULATE RETURN ADDRESS TO JUST AFTER JMP
STR R1 FP;//STORE RETURN ADDRESS
JMP RESET;

//SETUP TO CALL GETDATA()
//ALWAYS TEST FOR OVERFLOW
MOV R5 SP;
ADI R5 -8;//CHANGE TO THE NUMBER OF stored items X 4
CMP R5 SL;
BLT R5 OVERFLOW;
//ACTIVATION RECORD BEG
MOV R3 FP;//SAVE TO BE PFP
MOV FP SP;//SET FP
ADI SP -4;
STR R3 SP;STORE PFP
ADI SP -4;//ACTIVATION RECORD BEG
//****PASS PARAMETERS HERE****
//****END OF PARAMETERS****
MOV R1 PC;//ACTIVATION RECORD END
ADI R1 44;//CALCULATE RETURN ADDRESS TO JUST AFTER JMP
STR R1 FP;//STORE RETURN ADDRESS
JMP GETDATA;

WHILE LDR R1 CARRAY;
LDB R2 EXIT;
CMP R2 R1;
BRZ R2 ENDMAIN;
LDB R2 PLUS;
CMP R2 R1;
BRZ R2 CALLGETDATA;//ELSE 
LDB R2 MINUS;
CMP R2 R1;
BNZ R2 ELSE1;
//SETUP TO CALL GETDATA() //IF C[0] IS "+" OR "-"
//ALWAYS TEST FOR OVERFLOW
CALLGETDATA MOV R5 SP;
ADI R5 -8;//CHANGE TO THE NUMBER OF stored items X 4
CMP R5 SL;
BLT R5 OVERFLOW;
//ACTIVATION RECORD BEG
MOV R3 FP;//SAVE TO BE PFP
MOV FP SP;//SET FP
ADI SP -4;
STR R3 SP;STORE PFP
ADI SP -4;//ACTIVATION RECORD BEG
//****PASS PARAMETERS HERE****
//****END OF PARAMETERS****
MOV R1 PC;//ACTIVATION RECORD END
ADI R1 44;//CALCULATE RETURN ADDRESS TO JUST AFTER JMP
STR R1 FP;//STORE RETURN ADDRESS
JMP GETDATA;
JMP ENDIF1;
ELSE1 LDA R1 CARRAY;
LDR R2 R1;//R2 HAS C[0]
ADI R1 4;
STR R2 R1;//C[1] = C[0]
ADI R1 -4;
LDB R3 PLUS;
STR R3 R1;//C[0] = "+"
LDR R2 CNT;
ADI R2 1;
LDA R3 CNT;
STR R2 R3;//CNT++
ENDIF1 JMP WHILE22;

//1ST INNER WHILE LOOP
WHILE22 LDR R1 DATA;
LDR R2 ONE;
CMP R2 R1;
BNZ R2 ENDWHILE22;
LDR R1 CNT;//GET VALUE OF CNT
LDR R4 FOUR;
MUL R1 R4;
ADI R1 -4;//GET INDEX [CNT-1]
LDA R2 CARRAY;
ADD R2 R1;//PTR TO C[CNT-1]
LDR R3 R2;//GET VALUE AT C[CNT-1]
LDR R4 CRETURN;//GET "\R"
CMP R3 R4;
BNZ R3 CALLGETDATA22;//ELSE C[CNT-1] != "\R"			
LDR R3 ZERO;//R3=0											LDR 3 124
LDA R4 DATA;//R4=PTR TO DATA								LDA 4 32
STR R3 R4;//DATA=0											STR 3 4
LDR R3 ONE;//R3=0
LDA R4 TENTH;//R4=PTR TO TENTH
STR R3 R4;//TENTH=1
LDR R1 CNT;//GET VALUE OF CNT
ADI R1 -2;//CNT - 2
LDA R2 CNT;//PTR TO CNT
STR R1 R2;//CNT=CNT-2

//2ND INNER WHILE LOOP
WHILE333 LDR R2 FLAG;//R2=VALUE AT FLAG
LDR R3 ZERO;//R3=0
CMP R2 R3;
BNZ R2 ENDWHILE333;//!FLAG. BRANCH IF FLAG IS NOT 0, WAS 1
LDR R1 CNT;//R1=VALUE AT CNT
CMP R1 R3;
BRZ R1 ENDWHILE333;//CNT != 0, WAS > 0
//SETUP TO CALL OPD()
//ALWAYS TEST FOR OVERFLOW
MOV R5 SP;
ADI R5 -20;//CHANGE TO THE NUMBER OF stored items X 4
CMP R5 SL;
BLT R5 OVERFLOW;
//ACTIVATION RECORD BEG
MOV R3 FP;//SAVE TO BE PFP
MOV FP SP;//SET FP
ADI SP -4;
STR R3 SP;STORE PFP
ADI SP -4;//ACTIVATION RECORD BEG
//****PASS PARAMETERS HERE****
LDR R2 CARRAY;//R2=C[0]
STR R2 SP;//C[0]
ADI SP -4;
LDR R2 TENTH;
STR R2 SP;//TENTH
ADI SP -4;
LDR R2 CNT;//R2=VALUE AT CNT
LDR R4 FOUR;
MUL R2 R4;//GET INDEX OF CARRAY
LDA R3 CARRAY;//R3=PTR TO CARRAY
ADD R3 R2;//R3=PTR TO C[CNT]
LDR R2 R3;//R2=C[CNT]
STR R2 SP;//C[CNT]
ADI SP -4;
//****END OF PARAMETERS****
MOV R1 PC;//ACTIVATION RECORD END
ADI R1 44;//CALCULATE RETURN ADDRESS TO JUST AFTER JMP
STR R1 FP;//STORE RETURN ADDRESS
JMP OPD;
LDA R1 CNT;//R1=PTR TO CNT
LDR R2 R1;//R2=CNT
ADI R2 -1;//CNT--
STR R2 R1;//CNT=CNT--
LDA R1 TENTH;//R1=PTR TO TENTH
LDR R2 R1;//R2=TENTH
LDR R3 TEN;//R3=10
MUL R2 R3;//R2=TENTH*10
STR R2 R1;//TENTH=TENTH*10
JMP WHILE333;
ENDWHILE333 LDR R1 FLAG;//R1=FLAG  //TEST !FLAG
LDR R2 ZERO;//R2=0
CMP R1 R2;
BNZ R1 WHILE22;//FLAG IS NOT 0, IS 1
JMP PRINTOP;//PRINT OPERAND. WILL JMP WHILE22 WHEN DONE.
//END OF MOST INNER WHILE AND AFTER IF(!FLAG) PRINT.

JMP ENDIF22;
//SETUP TO CALL GETDATA()
//ALWAYS TEST FOR OVERFLOW
CALLGETDATA22 MOV R5 SP;
ADI R5 -8;//CHANGE TO THE NUMBER OF stored items X 4
CMP R5 SL;
BLT R5 OVERFLOW;
//ACTIVATION RECORD BEG
MOV R3 FP;//SAVE TO BE PFP
MOV FP SP;//SET FP
ADI SP -4;
STR R3 SP;STORE PFP
ADI SP -4;//ACTIVATION RECORD BEG
//****PASS PARAMETERS HERE****
//****END OF PARAMETERS****
MOV R1 PC;//ACTIVATION RECORD END
ADI R1 44;//CALCULATE RETURN ADDRESS TO JUST AFTER JMP
STR R1 FP;//STORE RETURN ADDRESS
JMP GETDATA;

ENDIF22 JMP WHILE22;
 
//SETUP TO CALL RESET()
//ALWAYS TEST FOR OVERFLOW
ENDWHILE22 MOV R5 SP;//CALL RESET()
ADI R5 -28;//CHANGE TO THE NUMBER OF stored items X 4
CMP R5 SL;
BLT R5 OVERFLOW;
//ACTIVATION RECORD BEG
MOV R3 FP;//SAVE TO BE PFP
MOV FP SP;//SET FP
ADI SP -4;
STR R3 SP;STORE PFP
ADI SP -4;//ACTIVATION RECORD BEG
//****PASS PARAMETERS HERE****
LDR R2 ONE;
STR R2 SP;//W
ADI SP -4;
LDR R2 ZERO;
STR R2 SP;//X
ADI SP -4;
STR R2 SP;//Y
ADI SP -4;
STR R2 SP;//Z
ADI SP -4;
//****END OF PARAMETERS****
MOV R1 PC;//ACTIVATION RECORD END
ADI R1 44;//CALCULATE RETURN ADDRESS TO JUST AFTER JMP
STR R1 FP;//STORE RETURN ADDRESS
JMP RESET;

//SETUP TO CALL GETDATA() //IF C[0] IS "+" OR "-"
//ALWAYS TEST FOR OVERFLOW
MOV R5 SP;
ADI R5 -8;//CHANGE TO THE NUMBER OF stored items X 4
CMP R5 SL;
BLT R5 OVERFLOW;
//ACTIVATION RECORD BEG
MOV R3 FP;//SAVE TO BE PFP
MOV FP SP;//SET FP
ADI SP -4;
STR R3 SP;STORE PFP
ADI SP -4;//ACTIVATION RECORD BEG
//****PASS PARAMETERS HERE****
//****END OF PARAMETERS****
MOV R1 PC;//ACTIVATION RECORD END
ADI R1 44;//CALCULATE RETURN ADDRESS TO JUST AFTER JMP
STR R1 FP;//STORE RETURN ADDRESS
JMP GETDATA;
JMP WHILE;

ENDMAIN TRP 0;//END PROGRAM


//*******FUNCTIONS************

//RESET() //R1=K, R2=SIZE, R3=CMPS, R4=CARRAY, R5=CARRAY INDEX, R6=0, 
RESET LDR R1 ZERO;
LDR R2 SIZE;
LDA R4 CARRAY;
MOV R5 R4;
LDR R6 ZERO;
WHILERESET MOV R3 R1;
CMP R3 R2;
BRZ R3 ENDWHILERESET;
STR R6 R5;
ADI R5 4;//INCREMENT 4 BYTES to index CARRAY
ADI R1 1;//K++
JMP WHILERESET;
ENDWHILERESET ADI SP 4;//POP Z
LDR R1 SP;
LDA R2 FLAG;
STR R1 R2;
ADI SP 4;//POP Y
LDR R1 SP;
LDA R2 CNT;
STR R1 R2;
ADI SP 4;//POP X
LDR R1 SP;
LDA R2 OPDV;
STR R1 R2;
ADI SP 4;//POP W
LDR R1 SP;
LDA R2 DATA;
STR R1 R2;
//DE-ALLOCATE ACTIVATION RECORD
//ALWAYS TEST FOR UNDERFLOW
MOV SP FP;//DE-ALLOCATE CURRENT ACTIVATION RECORD
MOV R5 SP;
CMP R5 SB;
BGT R5 UNDERFLOW;
LDR R5 FP;
MOV R4 R5;
ADI R4 -4;
LDR FP R4;
JMR R5; 

//GETDATA()
GETDATA LDR R1 CNT;									JMP 2 
LDR R2 SIZE;
CMP R1 R2;
BRZ R1 ELSEGETDATA;
BGT R1 ELSEGETDATA;
LDR R1 CNT;//R1=CNT
LDR R3 FOUR;
MUL R1 R3;//R1=INDEX FOR CNT
LDA R2 CARRAY;//R2=PTR TO CARRAY
ADD R2 R1;//R2=PTR TO C[CNT]
TRP 4;
STR R0 R2;//C[CNT]=GETCHAR()
LDR R1 CNT;
ADI R1 1;
LDA R4 CNT;//CNT++
STR R1 R4;
JMP ENDIFGETDATA;
ELSEGETDATA LDB R0 N;
TRP 3;
LDB R0 U;
TRP 3;
LDB R0 M;
TRP 3;
LDB R0 B;
TRP 3;
LDB R0 E;
TRP 3;
LDB R0 R;
TRP 3;
LDB R0 SPACE;
TRP 3;
LDB R0 T;
TRP 3;
LDB R0 O;
TRP 3;
TRP 3;
LDB R0 SPACE;
TRP 3;
LDB R0 B;
TRP 3;
LDB R0 I;
TRP 3;
LDB R0 G;
TRP 3;
LDB R0 NEWLINE;
TRP 3;
JMP FLUSH;//FLUSH BUFFER
//DE-ALLOCATE ACTIVATION RECORD
//ALWAYS TEST FOR UNDERFLOW
ENDIFGETDATA MOV SP FP;//DE-ALLOCATE CURRENT ACTIVATION RECORD
MOV R5 SP;
CMP R5 SB;
BGT R5 UNDERFLOW;
LDR R5 FP;
MOV R4 R5;
ADI R4 -4;
LDR FP R4;
JMR R5; 

//OPD()
OPD LDR R1 CZERO;//R1=T=0
ADI SP 4;//POP J
LDR R2 SP;//R2=J
LDR R3 CZERO;//IF(J==0)
CMP R3 R2;
BNZ R3 J1;//ELSE IF (J==1)
LDR R1 CZERO;//T=0
JMP ENDIFOPD;//DONE

J1 LDR R3 CONE;//IF(J==1)
CMP R3 R2;
BNZ R3 J2;//ELSE IF (J==2)
LDR R1 CONE;//T=1
JMP ENDIFOPD;//DONE

J2 LDR R3 CTWO;//IF(J==2)
CMP R3 R2;
BNZ R3 J3;//ELSE IF (J==3)
LDR R1 CTWO;//T=2
JMP ENDIFOPD;//DONE

J3 LDR R3 CTHREE;//IF(J==3)
CMP R3 R2;
BNZ R3 J4;//ELSE IF (J==4)
LDR R1 CTHREE;//T=3
JMP ENDIFOPD;//DONE

J4 LDR R3 CFOUR;//IF(J==4)
CMP R3 R2;
BNZ R3 J5;//ELSE IF (J==5)
LDR R1 CFOUR;//T=4
JMP ENDIFOPD;//DONE

J5 LDR R3 CFIVE;//IF(J==5)
CMP R3 R2;
BNZ R3 J6;//ELSE IF (J==6)
LDR R1 CFIVE;//T=5
JMP ENDIFOPD;//DONE

J6 LDR R3 CSIX;//IF(J==6)
CMP R3 R2;
BNZ R3 J7;//ELSE IF (J==7)
LDR R1 CSIX;//T=6
JMP ENDIFOPD;//DONE

J7 LDR R3 CSEVEN;//IF(J==7)
CMP R3 R2;
BNZ R3 J8;//ELSE IF (J==8)
LDR R1 CSEVEN;//T=7
JMP ENDIFOPD;//DONE

J8 LDR R3 CEIGHT;//IF(J==8)
CMP R3 R2;
BNZ R3 J9;//ELSE IF (J==9)
LDR R1 CEIGHT;//T=8
JMP ENDIFOPD;//DONE

J9 LDR R3 CNINE;//IF(J==9)
CMP R3 R2;
BNZ R3 ISNOTNUM;//ELSE ISNOTNUM
LDR R1 CNINE;//T=9

ENDIFOPD LDR R3 FLAG;//R3=FLAG  //TEST !FLAG
LDR R2 ZERO;//R2=0
CMP R3 R2;
BNZ R3 ENDOPD;//FLAG IS NOT 0, IS 1
ADI SP 4;//POP K
LDR R3 SP;//R3=K
ADI SP 4;//POP S
LDR R2 SP;//R2=S
LDR R4 PLUS;//R4="+"
CMP R2 R4;//IF(S == '+')
BNZ R2 ELSEOPD;
MUL R1 R3;//R1=T*K
JMP ENDIFOPD22;
ELSEOPD LDR R2 ZERO;
ADI R2 -1;
MUL R3 R2;//R3= -K
MUL R1 R3;//R1=T*-K
ENDIFOPD22 LDA R4 OPDV;//R4=PTR TO OPDV
LDR R2 R4;//R2=VALUE AT OPDV
ADD R2 R1;//OPDV += T
STR R2 R4;//STORE OPDV
//DE-ALLOCATE ACTIVATION RECORD
//ALWAYS TEST FOR UNDERFLOW
ENDOPD MOV SP FP;//DE-ALLOCATE CURRENT ACTIVATION RECORD
MOV R5 SP;
CMP R5 SB;
BGT R5 UNDERFLOW;
LDR R5 FP;
MOV R4 R5;
ADI R4 -4;
LDR FP R4;
JMR R5; 

//ISNOTNUM
ISNOTNUM MOV R0 R2;PRINT J
TRP 3;
LDB R0 SPACE;
TRP 3;
LDB R0 I;
TRP 3;
LDB R0 S;
TRP 3;
LDB R0 SPACE;
TRP 3;
LDB R0 N;
TRP 3;
LDB R0 O;
TRP 3;
LDB R0 T;
TRP 3;
LDB R0 SPACE;
TRP 3;
LDB R0 A;
TRP 3;
LDB R0 SPACE;
TRP 3;
LDB R0 N;
TRP 3;
LDB R0 U;
TRP 3;
LDB R0 M;
TRP 3;
LDB R0 B;
TRP 3;
LDB R0 E;
TRP 3;
LDB R0 R;
TRP 3;
LDB R0 NEWLINE;
TRP 3;
LDA R1 FLAG;//R1=PTR TO FLAG
LDR R2 ONE;
STR R2 R1;//FLAG=1
JMP ENDIFOPD;

//FLUSH()
FLUSH LDR R1 ZERO;//R1=0
LDA R2 DATA;//R2=PTR TO DATA
STR R1 R2;//DATA=0
TRP 4;//GETCHAR()
LDB R1 CRETURN;
WHILEFLUSH CMP R0 R1;//C[0] != '\N'
BRZ R0 ENDWHILEFLUSH;//C[0] == '\N'
TRP 4;
JMP WHILEFLUSH;//LOOP BACK AGAIN
ENDWHILEFLUSH JMP ENDIFGETDATA;

//OVERFLOW
OVERFLOW LDB R0 O;
TRP 3;
LDB R0 V;
TRP 3;
LDB R0 E;
TRP 3;
LDB R0 R;
TRP 3;
LDB R0 F;
TRP 3;
LDB R0 L;
TRP 3;
LDB R0 O;
TRP 3;
LDB R0 W;
TRP 3;
TRP 0;

//UNDERFLOW
UNDERFLOW LDB R0 O;
TRP 3;
LDB R0 U;
TRP 3;
LDB R0 N;
TRP 3;
LDB R0 D;
TRP 3;
LDB R0 E;
TRP 3;
LDB R0 R;
TRP 3;
LDB R0 F;
TRP 3;
LDB R0 L;
TRP 3;
LDB R0 O;
TRP 3;
LDB R0 W;
TRP 3;
TRP 0;

//PRINTOP
PRINTOP LDB R0 O;
TRP 3;
LDB R0 P;
TRP 3;
LDB R0 E;
TRP 3;
LDB R0 R;
TRP 3;
LDB R0 A;
TRP 3;
LDB R0 N;
TRP 3;
LDB R0 D;
TRP 3;
LDB R0 SPACE;
TRP 3;
LDB R0 I;
TRP 3;
LDB R0 S;
TRP 3;
LDB R0 SPACE;
TRP 3;
LDR R0 OPDV;
TRP 1;
LDB R0 NEWLINE;
TRP 3;
JMP WHILE22;